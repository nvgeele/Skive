#lang racket

(require "../src/expand.rkt")
(require "../src/analyse.rkt")
(require "../src/compile.rkt")

(define prog1
  '(if (= 0 1) 1 2))

(define prog2
  '(let ((y (lambda (f)
	      ((lambda (x) (x x))
	       (lambda (x) (f (lambda (y) ((x x) y)))))))
	 (almost-fac (lambda (f) 
		       (lambda (n)
			 (if (= n 0)
			   1
			   (* n (f (- n 1))))))))
     (let ((fac (y almost-fac)))
       (fac 10))))

(define prog3
  '(let ((y (lambda (f)
	      ((lambda (x) (x x))
	       (lambda (x) (f (lambda (y) ((x x) y)))))))
	 (almost-fib (lambda (f)
		       (lambda (n)
			 (if (or (= n 0) (= n 1))
			   1
			   (+ (f (- n 1)) (f (- n 2))))))))
     (let ((fib (y almost-fib)))
       (fib 30))))


(define (do-test prog)
  (let* ((output (open-output-file "/tmp/code.if1" #:exists 'truncate)))
    (display (compile-skive-to-if1 prog) output)
    (close-output-port output)
    (display "done!\n")))

(define (fib n)
  (if (or (= n 0) (= n 1))
    1
    (+ (fib (- n 1)) (fib (- n 2)))))
